import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtin-modules';
import path from 'path';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === 'production';

// Plugin to resolve the virtual Wasm modules to the build artifacts directory
const wasmResolverPlugin = {
  name: 'wasm-resolver',
  setup(build) {
    // Resolve 'ocr-wasm-engine' -> build/wasm-artifacts/ocr-wasm.js
    build.onResolve({ filter: /^ocr-wasm-engine$/ }, (args) => {
      return {
        path: path.resolve(
          '..',
          '..',
          'build',
          'wasm-artifacts',
          'ocr-wasm.js',
        ),
      };
    });

    // Resolve 'ocr-wasm-engine/binary' -> build/wasm-artifacts/ocr-wasm.wasm
    build.onResolve({ filter: /^ocr-wasm-engine\/binary$/ }, (args) => {
      return {
        path: path.resolve(
          '..',
          '..',
          'build',
          'wasm-artifacts',
          'ocr-wasm.wasm',
        ),
      };
    });
  },
};

// Plugin to compile worker code and inject it as a string
const workerPlugin = {
  name: 'worker-plugin',
  setup(build) {
    build.onResolve({ filter: /^worker:ocr$/ }, (args) => ({
      path: args.path,
      namespace: 'worker-ns',
    }));

    build.onLoad({ filter: /.*/, namespace: 'worker-ns' }, async () => {
      const workerEntry = path.join(process.cwd(), 'worker', 'ocr-worker.ts');
      try {
        const result = await esbuild.build({
          entryPoints: [workerEntry],
          bundle: true,
          format: 'iife',
          target: 'es2018',
          platform: 'browser', // Target browser environment
          plugins: [wasmResolverPlugin], // Reuse resolver so worker finds Wasm
          loader: { '.wasm': 'binary' },
          external: ['fs', 'path', 'crypto'], // Ignore Node built-ins in Emscripten glue
          write: false,
          minify: prod,
        });
        const text = result.outputFiles[0].text;
        return {
          contents: `export default ${JSON.stringify(text)};`,
          loader: 'js',
        };
      } catch (e) {
        console.error('Worker Build Failed:', e);
        return { errors: e.errors };
      }
    });
  },
};

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ['main.ts'],
  bundle: true,
  plugins: [wasmResolverPlugin, workerPlugin], // Add the resolver plugin
  external: [
    'obsidian',
    'electron',
    '@codemirror/autocomplete',
    '@codemirror/closebrackets',
    '@codemirror/collab',
    '@codemirror/commands',
    '@codemirror/comment',
    '@codemirror/fold',
    '@codemirror/gutter',
    '@codemirror/highlight',
    '@codemirror/history',
    '@codemirror/language',
    '@codemirror/lint',
    '@codemirror/matchbrackets',
    '@codemirror/panel',
    '@codemirror/rangeset',
    '@codemirror/rectangular-selection',
    '@codemirror/search',
    '@codemirror/state',
    '@codemirror/stream-parser',
    '@codemirror/text',
    '@codemirror/tooltip',
    '@codemirror/view',
    ...builtins,
  ],
  format: 'cjs',
  target: 'es2018',
  logLevel: 'info',
  sourcemap: prod ? false : 'inline',
  treeShaking: true,
  outfile: 'main.js',
  loader: {
    '.wasm': 'binary',
    '.data': 'binary',
  },
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
